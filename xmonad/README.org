#+TITLE: Xmonad
#+PROPERTY: header-args :tangle ~/.xmonad/xmonad.hs
*   Table of contents :toc:
- [[#imports][Imports]]
- [[#some-variables][Some variables]]
  - [[#fonts][Fonts]]
  - [[#terminal][Terminal]]
  - [[#whether-focus-follows-the-mouse-pointer][Whether focus follows the mouse pointer.]]
  - [[#whether-clicking-on-a-window-to-focus-also-passes-the-click-to-the-window][Whether clicking on a window to focus also passes the click to the window]]
  - [[#width-of-the-window-border-in-pixels][Width of the window border in pixels.]]
  - [[#modmask][Modmask]]
  - [[#workspaces][Workspaces]]
  - [[#borders][Borders]]
- [[#layouts][Layouts]]
  - [[#mylayout][MyLayout]]
  - [[#attempting-to-set-a-fullscreen-layout][Attempting to set a fullscreen layout]]
- [[#manage-hook][Manage Hook]]
- [[#prompts][Prompts]]
- [[#bordersgaps][Borders/Gaps]]
- [[#startup-hook][Startup hook]]
- [[#my-keys-config][My Keys Config]]
- [[#mouse][Mouse]]
- [[#setting-fullscreen-support][Setting Fullscreen Support]]
- [[#xmobar][xmobar]]
- [[#myconfig][myConfig]]
- [[#the-main-event][the main event]]

* Imports
this secion is dedicated to the imports of the modules I would be using in the config 
#+begin_src haskell
  --import XMonad
  import XMonad hiding ((|||))
  import Data.Monoid
  import System.Exit
  import qualified XMonad.StackSet as W
  import qualified Data.Map        as M
  import XMonad.Hooks.ManageDocks
  import XMonad.Layout.NoBorders
  import Control.Monad
  import  Data.Maybe
  import Data.List
    -- Base
  import XMonad
  import System.IO
  import System.Exit (exitSuccess)
  import qualified XMonad.StackSet as W

      -- Actions
  import XMonad.Actions.CopyWindow (kill1, killAllOtherCopies)
  -- import XMonad.Actions.CycleWS (moveTo, shiftTo, WSType(..), nextScreen, prevScreen)
  import XMonad.Actions.CycleWS
  import XMonad.Actions.GridSelect
  import XMonad.Actions.MouseResize
  import XMonad.Actions.Promote
  import XMonad.Actions.RotSlaves 
  import qualified XMonad.Actions.TreeSelect as TS
  import XMonad.Actions.WindowGo 
  import XMonad.Actions.WithAll
  import qualified XMonad.Actions.Search as S
  -- import qualified DBus as D
  -- import qualified DBus.Client as D
  import qualified Codec.Binary.UTF8.String as UTF8
  --import  XMonad.Actions.Navigation2D

    --bar functions
  import XMonad.Hooks.StatusBar
  import XMonad.Hooks.StatusBar.PP

      -- Hooks
  import XMonad.Hooks.DynamicLog
  import XMonad.Hooks.EwmhDesktops  -- for some fullscreen events, also for xcomposite in obs.
  import XMonad.Hooks.FadeInactive
  import XMonad.Hooks.ManageDocks
  import XMonad.Hooks.ManageHelpers
  import XMonad.Hooks.ServerMode
  import XMonad.Hooks.SetWMName
  import XMonad.Hooks.WorkspaceHistory
  import XMonad.Hooks.Place
      -- Layouts
  import XMonad.Layout.GridVariants (Grid(Grid))
  import XMonad.Layout.SimplestFloat
  import XMonad.Layout.Spiral
  import XMonad.Layout.ResizableTile
  import XMonad.Layout.Tabbed
  import XMonad.Layout.ThreeColumns
  import XMonad.Layout.BinarySpacePartition
  import XMonad.Layout.SimpleFloat
  import XMonad.Layout.Renamed

  --import XMonad.Layout.Fullscreen as FS
      -- Layouts modifiers
  import XMonad.Layout.LayoutModifier
  import XMonad.Layout.LimitWindows 
  --import XMonad.Layout.Magnifier
  import XMonad.Layout.MultiToggle (mkToggle, single, EOT(EOT), (??))
  import XMonad.Layout.MultiToggle.Instances (StdTransformers(NBFULL, MIRROR, NOBORDERS))
  import XMonad.Layout.NoBorders
  import XMonad.Layout.Renamed (renamed, Rename(Replace))
  import XMonad.Layout.ShowWName
  import XMonad.Layout.Spacing
  import XMonad.Layout.WindowArranger (windowArrange, WindowArrangerMsg(..))
  import qualified XMonad.Layout.ToggleLayouts as T (toggleLayouts, ToggleLayout(Toggle))
  import qualified XMonad.Layout.MultiToggle as MT (Toggle(..))

      -- Prompt
  import XMonad.Prompt
  import XMonad.Prompt.Input
  import XMonad.Prompt.FuzzyMatch
  import XMonad.Prompt.Man
  import XMonad.Prompt.Pass
  import XMonad.Prompt.Shell
  import XMonad.Prompt.Ssh
  import XMonad.Prompt.XMonad
  import XMonad.Prompt.AppLauncher
  import Control.Arrow (first)
  import XMonad.Prompt.Workspace
  import Data.Char

      -- Utilities
  import XMonad.Util.EZConfig 
  import XMonad.Util.NamedScratchpad
  import XMonad.Util.Run 
  import XMonad.Util.SpawnOnce
  import XMonad.Util.Loggers

  --Others
  import XMonad.Layout.MultiToggle.Instances
  import XMonad.Layout.MultiToggle
  --import Theme
  import Theme.Theme
#+end_src

* Some variables
+ here I set some variables (Fonts, Terminal and some mouse related stuff)
** Fonts
#+begin_src haskell
  fontFamily :: String
  fontFamilyLarge :: String
  fontFamily = "xft:FiraCode Nerd Font:size=10:antialias=true:hinting=true"
  fontFamilyLarge = "xft:FiraCode Nerd Font:size=16:style=Bold:antialias=true:hinting=true"
#+end_src
** Terminal
+ The preferred terminal program, which is used in a binding below and by certain contrib modules.
#+begin_src haskell
  myTerminal :: String
  myTerminal = "alacritty"
#+end_src

** Whether focus follows the mouse pointer.
#+begin_src haskell
  myFocusFollowsMouse :: Bool
  myFocusFollowsMouse = True
#+end_src

** Whether clicking on a window to focus also passes the click to the window
#+begin_src haskell
  myClickJustFocuses :: Bool
  myClickJustFocuses = False
#+end_src

** Width of the window border in pixels.
#+begin_src haskell
  myBorderWidth   = 1
#+end_src

** Modmask
+ modMask lets you specify which modkey you want to use. The default is mod1Mask ("left alt").Note that I am using mod4mask.  You may also consider using mod3Mask ("right alt"), which does not conflict with emacs keybindings. The"windows key" is usually mod4Mask.
#+begin_src haskell
  myModMask       = mod4Mask
#+end_src

** Workspaces
+ The default number of workspaces (virtual screens) and their names. By default we use numeric strings, but any string may be used as a workspace name. The number of workspaces determined by the length
  of this list.

#+begin_src haskell
  myWorkspaces    = ["1","2","3","4","5","6","7","8","9"]
#+end_src

** Borders  
+ Here I set colors for unfocused and focused windows, respectively.

#+begin_src haskell
  myNormalBorderColor  = base00
  myFocusedBorderColor = base13
  --dracula
  --myNormalBorderColor  = base00
  --myFocusedBorderColor = "#bd93f9" 
#+end_src

* Layouts
** MyLayout
Here I set the default layouts for the layouts. I mainly use tiled, simplestFloat and Full layouts
#+begin_src haskell

  --myLayout =  renamed [CutWordsLeft 1] (  avoidStruts ( spacingWithEdge 8 ( smartBorders ( tiled ||| simplestFloat )))) ||| smartBorders Full

  myLayout =  renamed [CutWordsLeft 1]
              $ avoidStruts
              $ spacingWithEdge 8
              $ smartBorders
              $ tiled ||| simplestFloat 
    where
       -- default tiling algorithm partitions the screen into two panes
       tiled   = Tall nmaster delta ratio

       -- The default number of windows in the master pane
       nmaster = 1

       -- Default proportion of screen occupied by master pane
       ratio   = 1/2

       -- Percent of screen to increment by when resizing panes
       delta   = 3/100

#+end_src

** Attempting to set a fullscreen layout
  #+begin_src haskell
    
  #+end_src
* Manage Hook
#+begin_src haskell
myManageHook = composeAll
      [
        resource  =? "desktop_window" --> doIgnore
      , resource  =? "kdesktop"       --> doIgnore
      , isFullscreen                  --> doFullFloat
      ] -- this one

#+end_src

* Prompts
here I set the run prompts for xmoand 
#+begin_src haskell

  promptConfig = def
    { font                = fontFamily
    , bgColor             = "#282a36"
    , fgColor             = "#f8f8f2"
    , bgHLight            = "#bd93f9"
    , fgHLight            = "#282a36"
    , borderColor         = "#bd93f9"
    , promptBorderWidth   = 0
    , position            = Top
    , height              = 20
    , historySize         = 256
    , historyFilter       = id
    , showCompletionOnTab = False
    , searchPredicate     = fuzzyMatch
    , sorter              = fuzzySort
    , defaultPrompter     = id $ map toLower
    , alwaysHighlight     = True
    , maxComplRows        = Just 5
    }
#+end_src

* Borders/Gaps
this is where I set the borders and gaps, 
#+begin_src haskell
  mySpacing :: Integer -> l a -> XMonad.Layout.LayoutModifier.ModifiedLayout Spacing l a
  mySpacing i = spacingRaw False (Border i i i i) True (Border i i i i) True
#+end_src

* Startup hook
Perform an arbitrary action each time xmonad starts or is restarted
with M-S-r.  Used by, e.g., XMonad.Layout.PerWorkspace to initialize
per-workspace layout choices.
By default, do nothing.

#+begin_src haskell
  myStartupHook = do
          spawnOnce "/usr/lib/notification-daemon-1.0/notification-daemon"
          --spawnOnce "/usr/libexec/notification-daemon"
          -- spawnOnce "deadd-notification-center&"
          spawnOnce "xsetroot -cursor_name left_ptr"
          spawnOnce "conky -c ~/.config/conky/xmoand/dracula-01.conkyrc"
          -- spawnOnce "emacs --daemon"
          -- spawnOnce "lxqt-notificationd&"
          --  spawnOnce "/usr/libexec/notification-daemon"
          spawnOnce "lxpolkit"
          spawnOnce "trayer --edge top --align right --widthtype request --SetDockType true --SetPartialStrut true --expand true  --transparent true  --tint 0x282a36 --alpha 0 --height 20 --padding 3 --iconspacing 3"
          --spawnOnce "polybar xmonad"
          spawnOnce "picom --experimental-backends"
          --spawnOnce "picom"
          -- spawnOnce "nitrogen --restore"
          spawnOnce "feh --bg-scale ~/dotfiles/wallpapers/summer_1am.jpg" 
          --spawnOnce "trayer --edge top --align right --widthtype request --SetDockType true --SetPartialStrut true --expand true  --transparent true  --tint 0x292d3e  --alpha 0 --height 20 --padding 1"
          --spawnOnce "stalonetray"
          --spawnOnce "pasystray"
          spawnOnce "nm-applet"
          -- spawnOnce "xiccd"
          -- spawnOnce "mate-power-manager"
          spawnOnce "xfce4-power-manager"
          spawnOnce "xfce4-clipman"
          -- spawnOnce "redshift -O 5000"
          spawnOnce "volumeicon"
          --spawnOnce "play  -v0.05  ~/Desktop/95.mp3"

#+end_src
* My Keys Config
this is where my keybindings go
#+begin_src haskell
  myKeys :: [(String, X ())]
  myKeys =
    [
     --xmonad
      ("M-S-r", spawn "xmonad --recompile; xmonad --restart")
    , ("M-S-q", io exitSuccess)

    --Keyboard Layouts
    -- , ("M-v c", spawn "setxkbmap us -variant colemak" )
    --  , ("M-v q", spawn "setxkbmap us" )

    --Prompts
      , ("M-w 1",                        shellPrompt promptConfig) --normal run prompt
      , ("M-w 2",                        manPrompt promptConfig) -- man prompt
      , ("M-w 3",                        xmonadPrompt promptConfig)       -- xmonadPrompt

     --Rofi Stuff
    , ("M-d", spawn "rofi -show drun -icon-theme Papirus -show-icons")
    , ("M-p", spawn " rofi -show powermenu -modi powermenu:~/Desktop/rofis/rofi-power-menu/rofi-power-menu")

  -- deadd
  --, ("M-s", spawn "kill -s USR1 $(pidof deadd-notification-center)")

    --Some Applications
    , ("M-S-f", spawn "firefox")
    , ("M-e", spawn "nemo")
    , ("M-v", spawn "pavucontrol")

    --emacs
    , ("M-a", spawn "emacsclient -c")
    , ("M-S-<Return>", spawn "emacs")

    --terminal
    , ("M-<Return>", spawn myTerminal)

    --window management
      --close
    , ("M-q", kill)
      --Rotate through the available layout algorithms
    , ("M-<Space>", sendMessage NextLayout)

      -- Resize viewed windows to the correct size
      , ("M-n", refresh)

      -- Move focus to the next window
      , ("M-<Tab>" , windows W.focusDown)

      -- Move focus to the next window
      , ("M-j", windows W.focusDown)

      -- Move focus to the previous window
      , ("M-k", windows W.focusUp)

      -- Move focus to the master window
      , ("M-h", windows W.focusMaster  )

      -- Swap the focused window and the master window
      , ("M-S-h", windows W.swapMaster)

      -- Swap the focused window with the next window
      , ("M-S-j", windows W.swapDown  )

      -- Swap the focused window with the previous window
      , ("M-S-k", windows W.swapUp    )

      -- Shrink the master area
      , ("M-C-h", sendMessage Shrink)

      -- Expand the master area
      , ("M-C-l", sendMessage Expand)
      --reset layout
      , ("M-S-m",  setLayout $ Layout myLayout)
      --toogle fullscreen
      ,  ("M-f", sendMessage (JumpToLayout "Full"))
      -- Push window back into tiling
      , ("M-S-<Space>", withFocused $ windows . W.sink)
      --reset layout
      --, ("M-S-<Tab>", setLayout $ XMonad.)
      -- Increment the number of windows in the master area
      , ("M-,", sendMessage (IncMasterN 1))

      -- Deincrement the number of windows in the master area
      , ("M-.", sendMessage (IncMasterN (-1)))

    ]
    ++

    [ (otherModMasks ++ "M-" ++ key, action tag)
          | (tag, key) <- zip(map show [1..9]) (map (\x -> show x) ([1..9]))
          , (otherModMasks, action) <- [ ("", windows . W.greedyView)
                                       , ("S-", windows . W.shift)]
          ]

#+end_src

* Mouse
Some mouse actions 
#+begin_src haskell

  myMouseBindings =
      [ ((modkey, button1), (\w -> focus w >> mouseMoveWindow w >> windows W.shiftMaster))
      , ((modkey, button2), (\w -> focus w >> windows W.shiftMaster))
      , ((modkey .|. shiftMask, button1), (\w -> focus w >> mouseResizeWindow w >> windows W.shiftMaster)) ]
    where
      modkey = mod4Mask
#+end_src

* Setting Fullscreen Support
this is used so that apps like fireox are able to properly fullscreen 
Note: as of xmonad 0.17, this may no longer be needed
#+begin_src haskell
  setFullscreenSupported :: X ()
  setFullscreenSupported = addSupported ["_NET_WM_STATE", "_NET_WM_STATE_FULLSCREEN"]

  addSupported :: [String] -> X ()
  addSupported props = withDisplay $ \dpy -> do
      r <- asks theRoot
      a <- getAtom "_NET_SUPPORTED"
      newSupportedList <- mapM (fmap fromIntegral . getAtom) props
      io $ do
        supportedList <- fmap (join . maybeToList) $ getWindowProperty32 dpy a r
        changeProperty32 dpy r a aTOM propModeReplace (nub $ newSupportedList ++ supportedList)
#+end_src

* xmobar
#+begin_src haskell
  myXmobarPP :: PP
  myXmobarPP = def
      {
       ppCurrent = xmobarColor "#f1fa8c" "" . wrap "[" "]"
      , ppHiddenNoWindows = xmobarColor "#6272a4" ""
      , ppTitle   = xmobarColor "#ff79c6"  "" . shorten 40
      , ppVisible = wrap "(" ")"
      , ppUrgent  = xmobarColor "#ff5555" "#f1fa8c"
      , ppLayout  = xmobarColor "#8be9fd" ""
      , ppSep = "<fc=#6272a4> \xf444 </fc>"
      }
     where
          formatFocused   = wrap (white    "") (white    "") . magenta . ppWindow
          formatUnfocused = wrap (lowWhite "[") (lowWhite "]") . blue    . ppWindow

          -- | Windows should have *some* title, which should not not exceed a
          -- sane length.
          ppWindow :: String -> String
          ppWindow = xmobarRaw . (\w -> if null w then "untitled" else w) . shorten 30

          blue, lowWhite, magenta, red, white, yellow :: String -> String
          magenta  = xmobarColor "#bd93f9" ""
          blue     = xmobarColor "#8be9fd" ""
          white    = xmobarColor "#f8f8f2" ""
          yellow   = xmobarColor "#f1fa8c" ""
          red      = xmobarColor "#ff5555" ""
          lowWhite = xmobarColor "#f8f8f2" ""
#+end_src

* myConfig
#+begin_src haskell
  myConfig = def
     {
    terminal           = myTerminal,
    focusFollowsMouse  = myFocusFollowsMouse,
    clickJustFocuses   = myClickJustFocuses,
    borderWidth        = myBorderWidth,
    modMask            = myModMask,
    workspaces         = myWorkspaces,
    normalBorderColor  = myNormalBorderColor,
    focusedBorderColor = myFocusedBorderColor,
   -- hooks, layouts
     manageHook         =  myManageHook,
                   -- <+> manageDocks,
     handleEventHook    = handleEventHook def,
     layoutHook         =  myLayout ,
     startupHook        =    setWMName "LG3D" <+> myStartupHook
      }
    `additionalKeysP` myKeys `additionalMouseBindings` myMouseBindings
#+end_src

* the main event
this is the ~main~ variable for xmoand 
#+begin_src haskell
  main :: IO ()
  main = xmonad
       . ewmhFullscreen
       . ewmh
       . withEasySB (statusBarProp "/home/drishal/.local/bin/xmobar ~/dotfiles/xmobar.hs" (pure myXmobarPP)) defToggleStrutsKey
       $ myConfig
#+end_src
